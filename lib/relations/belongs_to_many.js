// Generated by CoffeeScript 1.12.4
var Rejected, assign, forceTransaction, ref;

ref = require('../utils'), Rejected = ref.Rejected, forceTransaction = ref.forceTransaction;

assign = require('./has_many').assign;

module.exports = {
  assign: assign,
  attach: function(model, relation, list, options) {
    return forceTransaction(relation.model.transaction, options, (function(_this) {
      return function(options) {
        var e, i, len, obj, other, unsaved;
        try {
          unsaved = [];
          other = [];
          for (i = 0, len = list.length; i < len; i++) {
            obj = list[i];
            switch (false) {
              case typeof obj !== 'number':
                other.push(obj);
                break;
              case !(obj instanceof _this.model && (obj.id != null)):
                other.push(obj);
                break;
              case !(obj instanceof _this.model):
                unsaved.push(obj);
                break;
              case obj.constructor !== Object:
                unsaved.push(_this.model.forge(obj));
                break;
              default:
                throw new Error("Can't attach " + obj + " to " + model + " as a " + relation.name);
            }
          }
          unsaved = unsaved.map(function(obj) {
            return obj.save(null, options);
          });
          return Promise.all(unsaved).then(function(saved) {
            list = saved.concat(other);
            return model.triggerThen('attaching', model, relation, list, options).then(function() {
              return _this._originalAttach(list, options);
            }).then(function(result) {
              return model.triggerThen('attached', model, relation, result, options);
            });
          });
        } catch (error) {
          e = error;
          return Rejected(e);
        }
      };
    })(this));
  },
  detach: function(model, relation, list, options) {
    return forceTransaction(relation.model.transaction, options, (function(_this) {
      return function(options) {
        return model.triggerThen('detaching', model, relation, list, options).then(function() {
          return _this._originalDetach(list, options);
        }).then(function(result) {
          return model.triggerThen('detached', model, relation, result, options);
        });
      };
    })(this));
  }
};
