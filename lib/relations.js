// Generated by CoffeeScript 1.12.4

/*
 *
 *  BelongsTo 'user', User
 *      leads to
 *      user: -> @belongsTo User
 *
 *  BelongsTo User
 *      leads to
 *      <User.name.toLowerCase()>: -> @belongsTo User
 *
 *  BelongsTo 'user', User, -> @where(username: 'foo')
 *      leads to
 *      user: -> relation = @belongsTo(User); f.call(relation)
 *
 *  class User extends db.Model
 *      tableName: 'users'
 *      @schema [
 *          HasMany Photo
 *      ]
 *
 *  class Photo extends db.Model
 *      tableName: 'photos'
 *      @schema [
 *          BelongsTo User
 *      ]
 *
 *  Photo.forge(id: 1).fetch(withRelated: 'user').then (photo) ->
 *      photo.user                              # function
 *      photo.related('user')                   # Collection
 *      photo.$user                             # Collection
 *      photo.$user.assign(user)                # set user_id to user.id and save
 *
 *  User.forge(id: 1).fetch(withRelated: 'photos').then (user) ->
 *      user.photos                             # function
 *      user.related('photos')                  # Collection
 *      user.$photos                            # Collection
 *      user.$photos.assign(...)                # detach all photos and attach listed
 *      user.$photos.attach(...)                # attach listed photos and save them
 *      user.$photos.detach(...)                # detach listed photos
 *
 *  class User extends db.Model
 *      tableName: 'users'
 *      @schema [
 *          HasMany Photo, onDestroy: (cascade|cascade direct|detach|detach direct|reject|ignore)
 *      ]
 *
 */
var BelongsTo, BelongsToMany, Field, Fulfilled, HasMany, HasOne, IntField, MorphMany, MorphOne, MorphTo, Rejected, Relation, StringField, camelize, lowerFirst, pluck, pluralize, promiseFinally, pushField, ref, ref1, ref2, singularize, upperFirst, values,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = require('inflection'), pluralize = ref.pluralize, singularize = ref.singularize, camelize = ref.camelize;

ref1 = require('./fields'), Field = ref1.Field, IntField = ref1.IntField, StringField = ref1.StringField;

ref2 = require('./utils'), Fulfilled = ref2.Fulfilled, Rejected = ref2.Rejected, promiseFinally = ref2.promiseFinally, values = ref2.values, pluck = ref2.pluck, upperFirst = ref2.upperFirst, lowerFirst = ref2.lowerFirst;

pushField = function(schema, name, factory) {
  var f, i, len;
  for (i = 0, len = schema.length; i < len; i++) {
    f = schema[i];
    if (f instanceof Field) {
      if (f.name === name) {
        return;
      }
    }
  }
  return schema.push(factory());
};

Relation = (function() {
  Relation.multiple = false;

  Relation.prototype.idSuffix = "_id";

  Relation.prototype.typeSuffix = "_type";

  function Relation(model, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof Relation)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Relation, arguments, function(){});
    }
    this.relatedModel = model;
    this.options = options;
    this.name = this._deduceName(this.relatedModel);
  }

  Relation.prototype.getIDName = function(n) {
    return "" + (n || this._relatedModelName().toLowerCase()) + this.idSuffix;
  };

  Relation.prototype.getTypeName = function(n) {
    return "" + (n || this._relatedModelName().toLowerCase()) + this.typeSuffix;
  };

  Relation.prototype.pluginOption = function(name, defaultVal) {
    return this.model.__bookshelf_schema_options[name] || defaultVal;
  };

  Relation.prototype.option = function(name, pluginOptionName, defaultVal) {
    var value;
    if (arguments.length === 2) {
      defaultVal = pluginOptionName;
      pluginOptionName = name;
    }
    value = this.options[name];
    if (value == null) {
      value = this.pluginOption(pluginOptionName, defaultVal);
    }
    return value;
  };

  Relation.prototype.contributeToSchema = function(schema) {
    return schema.push(this);
  };

  Relation.prototype.contributeToModel = function(cls) {
    this.model = cls;
    this.accessor = this.options.accessor || this._deduceAccessorName(this.name);
    if (!(this.name in cls.prototype)) {
      cls.prototype[this.name] = this.createRelation(cls);
    }
    if (this.option('createProperty', 'createProperties', true)) {
      return this._createProperty(cls);
    }
  };

  Relation.prototype.createRelation = function(cls) {
    var relation, self;
    relation = this._createRelation();
    relation = this._applyQuery(relation);
    relation = this._applyThrough(relation);
    self = this;
    return function() {
      return self._augementRelated(this, relation.apply(this, arguments));
    };
  };

  Relation.prototype.createGetter = function() {
    var self;
    self = this;
    return function() {
      var related;
      related = this.related(self.name);
      if (!related.__augemented) {
        self._augementRelated(this, related);
      }
      return related;
    };
  };

  Relation.prototype.createSetter = function() {
    return void 0;
  };

  Relation.prototype.onDestroy = function(model, options) {
    switch (this.option('onDestroy', 'ignore')) {
      case 'ignore':
        break;
      case 'cascade':
        return this._destroyCascade(model, options);
      case 'reject':
        return this._destroyReject(model, options);
      case 'detach':
        return this._destroyDetach(model, options);
    }
  };

  Relation.prototype._destroyCascade = function(model, options) {
    if (this.constructor.multiple) {
      return model[this.name]().fetch(options).then(function(related) {
        return related.forEach(function(obj) {
          var key;
          key = obj.tableName + ":" + obj.id;
          if (options.destroyingCache[key] == null) {
            return options.destroyingCache[key] = obj.destroy(options);
          }
        });
      });
    } else {
      return model[this.name]().fetch(options).then(function(obj) {
        var key;
        if (obj != null) {
          key = obj.tableName + ":" + obj.id;
          return options.destroyingCache[key] = obj.destroy(options);
        }
      });
    }
  };

  Relation.prototype._destroyReject = function(model, options) {
    if (this.constructor.multiple) {
      return model[this.accessor].fetch(options).then(function(related) {
        var i, len, obj;
        for (i = 0, len = related.length; i < len; i++) {
          obj = related[i];
          if (!((obj.tableName + ":" + obj.id) in options.destroyingCache)) {
            return Rejected(new Error("destroy was reject"));
          }
        }
      });
    } else {
      return model[this.name]().fetch(options).then(function(obj) {
        if (obj && !((obj.tableName + ":" + obj.id) in options.destroyingCache)) {
          return Rejected(new Error('destroy rejected'));
        }
      });
    }
  };

  Relation.prototype._destroyDetach = function(model, options) {
    if (this.constructor.multiple) {
      return model[this.accessor].assign([], options);
    } else {
      return model[this.accessor].assign(null, options);
    }
  };

  Relation.prototype._applyThrough = function(builder) {
    var interim, otherKey, throughForeignKey;
    if (!this.options.through) {
      return builder;
    }
    interim = this.options.through;
    throughForeignKey = this.options.throughForeignKey;
    otherKey = this.options.otherKey;
    return function() {
      return builder.call(this).through(interim, throughForeignKey, otherKey);
    };
  };

  Relation.prototype._applyQuery = function(builder) {
    var query;
    if (!this.options.query) {
      return builder;
    }
    query = this.options.query;
    return function() {
      return query.apply(builder.call(this));
    };
  };

  Relation.prototype._augementRelated = function(parent, related) {
    var fn, method, name, ref3, self;
    if (!this.constructor.injectedMethods) {
      return related;
    }
    self = this;
    ref3 = this.constructor.injectedMethods;
    fn = function(method) {
      if (name in related) {
        related["_original" + (upperFirst(name))] = related[name];
      }
      return related[name] = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        args = [parent, self].concat(args);
        return method.apply(this, args);
      };
    };
    for (name in ref3) {
      method = ref3[name];
      fn(method);
    }
    related.__augemented = true;
    return related;
  };

  Relation.prototype._createProperty = function(cls) {
    var getter, setter, spec;
    if (this.name === 'id' || this.accessor in cls.prototype) {
      return;
    }
    spec = {};
    getter = this.createGetter();
    setter = this.createSetter();
    if (getter) {
      spec.get = getter;
    }
    if (setter) {
      spec.set = setter;
    }
    return Object.defineProperty(cls.prototype, this.accessor, spec);
  };

  Relation.prototype._relatedModelName = function() {
    switch (false) {
      case typeof this.relatedModel !== 'string':
        return this.relatedModel;
      case !this.relatedModel.name:
        return this.relatedModel.name;
      case !this.relatedModel.displayName:
        return this.relatedModel.displayName;
      case !this.relatedModel.prototype.tableName:
        return singularize(camelize(this.relatedModel.prototype.tableName));
      default:
        throw new Error("Can't deduce related model name, try to pass \"name\" as an option");
    }
  };

  Relation.prototype._deduceName = function() {
    if (this.options.name != null) {
      return this.options.name;
    }
    if (this.constructor.multiple) {
      return pluralize(lowerFirst(this._relatedModelName()));
    } else {
      return lowerFirst(this._relatedModelName());
    }
  };

  Relation.prototype._deduceAccessorName = function() {
    return "" + (this.pluginOption('accessorPrefix', '$')) + this.name;
  };

  return Relation;

})();

HasOne = (function(superClass) {
  extend(HasOne, superClass);

  function HasOne(model, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof HasOne)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(HasOne, arguments, function(){});
    }
    HasOne.__super__.constructor.apply(this, arguments);
  }

  HasOne.injectedMethods = require('./relations/has_one');

  HasOne.prototype._createRelation = function() {
    var foreignKey, related;
    related = this.relatedModel;
    foreignKey = this.options.foreignKey;
    return function() {
      return this.hasOne(related, foreignKey);
    };
  };

  return HasOne;

})(Relation);

BelongsTo = (function(superClass) {
  extend(BelongsTo, superClass);

  function BelongsTo(model, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof BelongsTo)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(BelongsTo, arguments, function(){});
    }
    BelongsTo.__super__.constructor.apply(this, arguments);
  }

  BelongsTo.prototype.contributeToSchema = function(schema) {
    var foreignKey;
    BelongsTo.__super__.contributeToSchema.apply(this, arguments);
    foreignKey = this.options.foreignKey || this.getIDName();
    return pushField(schema, foreignKey, function() {
      return IntField(foreignKey);
    });
  };

  BelongsTo.injectedMethods = require('./relations/belongs_to');

  BelongsTo.prototype._destroyDetach = function(model, options) {};

  BelongsTo.prototype._createRelation = function() {
    var foreignKey, related;
    related = this.relatedModel;
    foreignKey = this.options.foreignKey;
    return function() {
      return this.belongsTo(related, foreignKey);
    };
  };

  BelongsTo.prototype._applyThrough = function(builder) {
    var interim, otherKey, throughForeignKey;
    if (!this.options.through) {
      return builder;
    }
    interim = this.options.through;
    throughForeignKey = this.options.throughForeignKey;
    otherKey = this.options.otherKey;
    return function() {
      var relation;
      relation = builder.call(this).through(interim, throughForeignKey, otherKey);
      relation.relatedData.joinClauses = BelongsTo._patchedJoinClauses;
      relation.relatedData.whereClauses = BelongsTo._patchedWhereClauses;
      return relation;
    };
  };

  BelongsTo._patchedJoinClauses = function(knex) {
    var joinTable, targetKey;
    joinTable = this.joinTable();
    targetKey = this.key('foreignKey');
    knex.join(joinTable, joinTable + '.' + targetKey, '=', this.targetTableName + '.' + this.targetIdAttribute);
    return knex.join(this.parentTableName + " as __parent", joinTable + "." + this.throughIdAttribute, '=', "__parent." + (this.key('throughForeignKey')));
  };

  BelongsTo._patchedWhereClauses = function(knex, resp) {
    var key;
    key = "__parent." + this.parentIdAttribute;
    return knex[resp ? 'whereIn' : 'where'](key, resp ? this.eagerKeys(resp) : this.parentFk);
  };

  return BelongsTo;

})(Relation);

HasMany = (function(superClass) {
  extend(HasMany, superClass);

  HasMany.multiple = true;

  function HasMany(model, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof HasMany)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(HasMany, arguments, function(){});
    }
    HasMany.__super__.constructor.apply(this, arguments);
  }

  HasMany.injectedMethods = require('./relations/has_many');

  HasMany.prototype._createRelation = function() {
    var foreignKey, related;
    related = this.relatedModel;
    foreignKey = this.options.foreignKey;
    return function() {
      return this.hasMany(related, foreignKey);
    };
  };

  return HasMany;

})(Relation);

BelongsToMany = (function(superClass) {
  extend(BelongsToMany, superClass);

  BelongsToMany.multiple = true;

  function BelongsToMany(model, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof BelongsToMany)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(BelongsToMany, arguments, function(){});
    }
    BelongsToMany.__super__.constructor.apply(this, arguments);
  }

  BelongsToMany.injectedMethods = require('./relations/belongs_to_many');

  BelongsToMany.prototype._destroyCascade = function(model, options) {
    var accessor;
    accessor = this.accessor;
    return model[this.name]().fetch(options).then(function(related) {
      return related.forEach(function(obj) {
        var key, pending;
        key = obj.tableName + ":" + obj.id;
        if (options.destroyingCache[key] == null) {
          pending = model[accessor].detach(obj, options).then(function() {
            return obj.destroy(options);
          });
          return options.destroyingCache[key] = pending;
        }
      });
    });
  };

  BelongsToMany.prototype._createRelation = function() {
    var foreignKey, otherKey, related, table;
    related = this.relatedModel;
    table = this.options.table;
    foreignKey = this.options.foreignKey;
    otherKey = this.options.otherKey;
    return function() {
      return this.belongsToMany(related, table, foreignKey, otherKey);
    };
  };

  return BelongsToMany;

})(Relation);

MorphOne = (function(superClass) {
  extend(MorphOne, superClass);

  function MorphOne(model, polymorphicName, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof MorphOne)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(MorphOne, arguments, function(){});
    }
    if (typeof polymorphicName !== 'string') {
      throw new Error('polymorphicName should be string');
    }
    MorphOne.__super__.constructor.call(this, model, options);
    this.polymorphicName = polymorphicName;
  }

  MorphOne.injectedMethods = require('./relations/morph_one');

  MorphOne.prototype._destroyDetach = function(model, options) {};

  MorphOne.prototype._createRelation = function() {
    var columnNames, morphValue, name, related;
    related = this.relatedModel;
    name = this.polymorphicName;
    columnNames = this.options.columnNames;
    morphValue = this.options.morphValue;
    return function() {
      return this.morphOne(related, name, columnNames, morphValue);
    };
  };

  return MorphOne;

})(Relation);

MorphMany = (function(superClass) {
  extend(MorphMany, superClass);

  MorphMany.multiple = true;

  function MorphMany(model, polymorphicName, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof MorphMany)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(MorphMany, arguments, function(){});
    }
    if (typeof polymorphicName !== 'string') {
      throw new Error('polymorphicName should be string');
    }
    MorphMany.__super__.constructor.call(this, model, options);
    this.polymorphicName = polymorphicName;
  }

  MorphMany.injectedMethods = require('./relations/morph_many');

  MorphMany.prototype._createRelation = function() {
    var columnNames, morphValue, name, related;
    related = this.relatedModel;
    name = this.polymorphicName;
    columnNames = this.options.columnNames;
    morphValue = this.options.morphValue;
    return function() {
      return this.morphMany(related, name, columnNames, morphValue);
    };
  };

  return MorphMany;

})(Relation);

MorphTo = (function(superClass) {
  extend(MorphTo, superClass);

  function MorphTo(polymorphicName, targets, options) {
    if (options == null) {
      options = {};
    }
    if (!(this instanceof MorphTo)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(MorphTo, arguments, function(){});
    }
    options.name = polymorphicName;
    MorphTo.__super__.constructor.call(this, targets, options);
    this.polymorphicName = polymorphicName;
  }

  MorphTo.injectedMethods = require('./relations/morph_to');

  MorphTo.prototype.contributeToSchema = function(schema) {
    var idName, typeName;
    MorphTo.__super__.contributeToSchema.apply(this, arguments);
    if (this.options.columnNames) {
      idName = this.options.polymorphicName[0];
      typeName = this.options.polymorphicName[1];
    } else {
      idName = this.getIDName(this.polymorphicName);
      typeName = this.getTypeName(this.polymorphicName);
    }
    pushField(schema, idName, function() {
      return IntField(idName);
    });
    return pushField(schema, typeName, function() {
      return StringField(typeName);
    });
  };

  MorphTo.prototype._destroyReject = function(model, options) {
    var polymorphicId, polymorphicType;
    polymorphicId = this.options.columnNames ? this.options.columnNames[0] : this.getIDName(this.polymorphicName);
    polymorphicType = this.options.columnNames ? this.options.columnNames[1] : this.getTypeName(this.polymorphicName);
    if ((model.get(polymorphicId) != null) && (model.get(polymorphicType) != null)) {
      return model[this.name]().fetch(options).then(function(obj) {
        if (obj && !((obj.tableName + ":" + obj.id) in options.destroyingCache)) {
          return Rejected(new Error('destroy rejected'));
        }
      });
    }
  };

  MorphTo.prototype._destroyDetach = function() {};

  MorphTo.prototype._createRelation = function() {
    var args;
    args = [this.polymorphicName];
    if (this.options.columnNames) {
      args.push(this.options.columnNames);
    }
    args = args.concat(this.relatedModel);
    return function() {
      return this.morphTo.apply(this, args);
    };
  };

  return MorphTo;

})(Relation);

module.exports = {
  HasOne: HasOne,
  BelongsTo: BelongsTo,
  HasMany: HasMany,
  BelongsToMany: BelongsToMany,
  MorphOne: MorphOne,
  MorphMany: MorphMany,
  MorphTo: MorphTo,
  Relation: Relation
};
